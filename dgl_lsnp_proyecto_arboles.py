# -*- coding: utf-8 -*-
"""DGL-LSNP-Proyecto-Arboles.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UnDtGMooMl0e8bBJIFuXEOdGSbDhOZpB

### **I. Acceso a datos y selección de características**

#### **1) Acceso a los datos**
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd               # Para la manipulación y análisis de datos
import numpy as np                # Para crear vectores y matrices n dimensionales
import matplotlib.pyplot as plt   # Para la generación de gráficas a partir de los datos
import seaborn as sns             # Para la visualización de datos basado en matplotlib
# %matplotlib inline

# Solicitar al usuario que ingrese el nombre del archivo
nombre_archivo = input("Ingrese el nombre del archivo CSV: ")
nombre_archivo = nombre_archivo + ".csv"
# Intentar leer el archivo CSV
try:
    # Leer el archivo CSV utilizando pandas
    Datos = pd.read_csv(nombre_archivo)
    print(Datos)
    
except FileNotFoundError:
    print("El archivo no existe o no se puede abrir.")
except:
    print("Ocurrió un error al leer el archivo.")

Datos.info()

# Solicitar al usuario que ingrese el nombre de la variable a analizar
variable_elegida = input("Ingrese el nombre de la variable que se va a agrupar: ")
print(Datos.groupby(variable_elegida).size())

Datos.describe()

"""#### **2) Selección de características**

A través de un mapa de calor de identifican posibles variables correlacionadas.
"""

plt.figure(figsize=(14,7))
MatrizInf = np.triu(Datos.corr())
sns.heatmap(Datos.corr(), cmap='RdBu_r', annot=True, mask=MatrizInf)
plt.show()

"""**Varibles seleccionadas:**

Debido a la importancia de las variables, se considerarán todas las variables para la construcción de los modelos.

#### **3) Definición de las variables predictoras y variable clase**
"""

#Variable clase
# Solicitar al usuario que ingrese el nombre de la variable clase
variable_clase = input("Ingrese el nombre de la variable clase: ")
Y = np.array(Datos[[variable_clase]])
pd.DataFrame(Y)

#Variables predictoras
# Crear una lista con todas las variables de la tabla
variables = list(Datos.columns)

# Verificar si la variable elegida está en la lista de variables
if variable_elegida in variables:
    # Eliminar la variable elegida de la lista
    variables.remove(variable_elegida)

    # Seleccionar todas las variables excepto la elegida
    X = Datos[variables]

    # Imprimir la tabla resultante
    print(X)
else:
    print("La variable elegida no está en la tabla.")

"""### **II. Creación de los modelos**"""

from sklearn import model_selection
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

X_train, X_validation, Y_train, Y_validation = model_selection.train_test_split(X, Y, 
                                                                                test_size = 0.2, 
                                                                                random_state = 0,
                                                                                shuffle = True)

print(len(X_train))
print(len(X_validation))

"""### **Modelo 1: Árboles de decisión (AD)**"""

from sklearn.tree import DecisionTreeClassifier

# Obtener solo las columnas numéricas
Datos_num = Datos.select_dtypes(include=[float, int])

#Se entrena el modelo a partir de los datos de entrada
ClasificacionAD = DecisionTreeClassifier(random_state=0)
ClasificacionAD.fit(X_train, Y_train)

#Clasificación final 
Y_ClasificacionAD = ClasificacionAD.predict(X_validation)
print(Y_ClasificacionAD)

ValoresMod1 = pd.DataFrame(Y_validation, Y_ClasificacionAD)
ValoresMod1

accuracy_score(Y_validation, Y_ClasificacionAD)

"""#### **Matriz de clasificación: Árbol de decisión**"""

#Matriz de clasificación
ModeloClasificacion1 = ClasificacionAD.predict(X_validation)
Matriz_Clasificacion1 = pd.crosstab(Y_validation.ravel(), 
                                   ModeloClasificacion1, 
                                   rownames=['Actual'], 
                                   colnames=['Clasificación']) 
Matriz_Clasificacion1

#Reporte de la clasificación
print('Criterio: \n', ClasificacionAD.criterion)
print('Importancia variables: \n', ClasificacionAD.feature_importances_)
print("Exactitud:", accuracy_score(Y_validation, Y_ClasificacionAD))
print(classification_report(Y_validation, Y_ClasificacionAD))

ImportanciaMod1 = pd.DataFrame({'Variable': list(X),
                                    'Importancia': ClasificacionAD.feature_importances_}).sort_values('Importancia', ascending=False)
ImportanciaMod1

from sklearn.tree import plot_tree
plt.figure(figsize=(16,16))  
plot_tree(ClasificacionAD, 
          feature_names = variables,
         class_names = ['1', '2', '3'])
plt.show()

from sklearn.tree import export_text
Reporte = export_text(ClasificacionAD, feature_names = variables)
print(Reporte)

"""### **Modelo 2: Bosques aleatorios (BA)**"""

from sklearn.ensemble import RandomForestClassifier

ClasificacionBA = RandomForestClassifier(random_state=0)
ClasificacionBA.fit(X_train, Y_train)

#Clasificación final 
Y_ClasificacionBA = ClasificacionBA.predict(X_validation)
print(Y_ClasificacionBA)

ValoresMod2 = pd.DataFrame(Y_validation, Y_ClasificacionBA)
ValoresMod2

accuracy_score(Y_validation, Y_ClasificacionBA)

"""#### **Matriz de clasificación: Bosques aleatorios**"""

#Matriz de clasificación
ModeloClasificacion2 = ClasificacionBA.predict(X_validation)
Matriz_Clasificacion2 = pd.crosstab(Y_validation.ravel(),
                                    ModeloClasificacion2,
                                    rownames=['Reales'],
                                    colnames=['Clasificación']) 
Matriz_Clasificacion2

#Reporte de la clasificación
print('Criterio: \n', ClasificacionBA.criterion)
print('Importancia variables: \n', ClasificacionBA.feature_importances_)
print("Exactitud:", accuracy_score(Y_validation, Y_ClasificacionBA))
print(classification_report(Y_validation, Y_ClasificacionBA))

Importancia2 = pd.DataFrame({'Variable': list(X), 
                             'Importancia': ClasificacionBA.feature_importances_}).sort_values('Importancia', ascending=False)
Importancia2

"""### **III. Validación**

"""

print("Árbol de decisión:", accuracy_score(Y_validation, Y_ClasificacionAD))
print("Bosque aleatorio:", accuracy_score(Y_validation, Y_ClasificacionBA))

#Rendimiento
from sklearn.preprocessing import label_binarize
y_score = ClasificacionBA.predict_proba(X_validation)
y_test_bin = label_binarize(Y_validation, classes=[1, 
                                                   2, 
                                                   3])
n_classes = y_test_bin.shape[1]

#Se calcula la curva ROC y el área bajo la curva
from sklearn.metrics import RocCurveDisplay
from sklearn import metrics
fig, ax = plt.subplots()
RocCurveDisplay.from_estimator(ClasificacionAD,
                               X_validation,
                               Y_validation,
                               ax = ax)
metrics.RocCurveDisplay.from_estimator(ClasificacionBA,
                                         X_validation,
                                         Y_validation,
                                         ax = ax)
plt.show()