# -*- coding: utf-8 -*-
"""DGL-LSNP-Proyecto-PCA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iYG1Tsbk8XJTPeQUeyysciGisHsdORLj
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd                     # Para la manipulación y análisis de datos
import numpy as np                      # Para crear vectores y matrices n dimensionales
import matplotlib.pyplot as plt         # Para la generación de gráficas a partir de los datos
import seaborn as sns                   # Para la visualización de datos basado en matplotlib
# %matplotlib inline                      
# Para generar imágenes dentro del cuaderno

# Solicitar al usuario que ingrese el nombre del archivo
nombre_archivo = input("Ingrese el nombre del archivo CSV: ")
nombre_archivo = nombre_archivo + ".csv"
# Intentar leer el archivo CSV
try:
    # Leer el archivo CSV utilizando pandas
    Datos = pd.read_csv(nombre_archivo)
    print(Datos)
    
except FileNotFoundError:
    print("El archivo no existe o no se puede abrir.")
except:
    print("Ocurrió un error al leer el archivo.")

"""Paso 1: Hay evidencia de variables posiblemente correlacionadas."""

DatosCorr = Datos.corr(method='pearson')
print(DatosCorr)

plt.figure(figsize=(14,7))
MatrizInf = np.triu(DatosCorr)
sns.heatmap(DatosCorr, cmap='RdBu_r', annot=True, mask=MatrizInf)
plt.show()

"""Paso 2: Se hace una estandarización de los datos"""

from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler, MinMaxScaler  

# Se instancia el objeto StandardScaler o MinMaxScaler 
Estandarizar = StandardScaler()                                  

# Seleccionar y eliminar columnas no numéricas
columnas_no_numericas = Datos.select_dtypes(exclude=['number']).columns
NuevaMatriz = Datos.drop(columnas_no_numericas, axis=1)

# Se calculan la media y desviación para cada variable, y se escalan los datos
MEstandarizada = Estandarizar.fit_transform(NuevaMatriz)         

print(pd.DataFrame(MEstandarizada, columns=NuevaMatriz.columns))

"""Pasos 3 y 4: Se calcula la matriz de covarianzas o correlaciones, y se calculan los componentes (eigen-vectores) y la varianza (eigen-valores)"""

#Selecciona la cantidad de componente
componentes = int(input("Ingrese el número de componentes a utilizar: "))

pca = PCA(n_components=componentes)     # pca=PCA(n_components=None), pca=PCA(.85)
pca.fit(MEstandarizada)          # Se obtiene los componentes
print(pca.components_)

"""Paso 5: Se decide el número de componentes principales"""

Varianza = pca.explained_variance_ratio_
print('Porporción de varianza:', Varianza)

suma_varianza = 0.0
nComp = 0

while suma_varianza < 0.80 or suma_varianza > 0.90:
    nComp += 1      
    # Calcular la suma de la varianza entre las posiciones 0 y 3 utilizando el parámetro
    suma_varianza = sum(Varianza[0:nComp])
    
print("El parámetro que cumple con la condición es:", nComp)
print('Varianza acumulada:', sum(Varianza[0:nComp]))

# Se grafica la varianza acumulada en las nuevas dimensiones
plt.plot(np.cumsum(pca.explained_variance_ratio_))
plt.xlabel('Número de componentes')
plt.ylabel('Varianza acumulada')
plt.grid()
plt.show()

"""Paso 6: Se examina la proporción de relevancias –cargas–"""

print(pd.DataFrame(abs(pca.components_)))

CargasComponentes = pd.DataFrame(pca.components_, columns=NuevaMatriz.columns)
print(CargasComponentes)

CargasComponentes = pd.DataFrame(abs(pca.components_), columns=NuevaMatriz.columns)
CargasComponentes

# Selecciona el valor de carga
carga = float(input("Ingrese el valor de carga: "))

# Iterar sobre las columnas de la tabla
for col in CargasComponentes.columns:
    # Verificar si algún valor en la columna es mayor que la carga
    if (CargasComponentes[col] > carga).any():
        # Eliminar la columna si el valor objetivo existe
        del CargasComponentes[col]

#print(DatosACP)
CargasComponentes

# Obtener los nombres de las columnas de ambas tablas
colDatos = set(Datos.columns)
colCargas = set(CargasComponentes.columns)

# Obtener las columnas que están en tabla1 pero no en tabla2
colEliminar = colDatos.difference(colCargas)

# Eliminar las columnas de tabla1 que no están en tabla2
DatosACP = Datos.drop(columns=colEliminar)

# Imprimir tabla1 actualizada
print(DatosACP)

"""II. Análisis correlacional de datos (ACD)"""

# Obtener las variables disponibles
variables_disponibles = Datos.columns

# Mostrar las variables disponibles para analizar
print("Variables disponibles:")
for variable in variables_disponibles:
    print(f"- {variable}")

# Solicitar al usuario que ingrese el nombre de la variable a analizar
variable_elegida = input("Ingrese el nombre de la variable que desea analizar: ")
sns.pairplot(Datos, hue=variable_elegida)
plt.show()

# Obtener las variables disponibles
variables_disponibles = Datos.columns

# Mostrar las variables disponibles para analizar
print("Variables disponibles:")
for variable in variables_disponibles:
    print(f"- {variable}")

# Solicitar al usuario que ingrese el nombre de la variable a analizar
variable_principal = input("Ingrese el nombre de la variable principal que desea analizar: ")
variable_x = input("Ingrese el nombre de la variable del eje x: ")
variable_y = input("Ingrese el nombre de la variable del eje y: ")

sns.scatterplot(x=variable_x, y =variable_y, data=Datos, hue=variable_principal)
plt.title('Gráfico de dispersión')
plt.xlabel(variable_x)
plt.ylabel(variable_y)
plt.show()